"use strict";
/*!
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const _1 = require(".");
const __1 = require("../..");
class RigidBody {
    /**
     * PUBLIC METHODS
     */
    /**
     * Creates a new RigidBody instance.
     * @param $owner The owning actor instance. Field name is prefixed with a dollar sign so that it is ignored by
     * the actor patch detection system.
     */
    constructor($owner) {
        this.$owner = $owner;
        // tslint:enable:variable-name
        this.enabled = true;
        this.mass = 1.0;
        this.detectCollisions = true;
        this.collisionDetectionMode = _1.CollisionDetectionMode.Discrete;
        this.useGravity = true;
        this._velocity = __1.Vector3.Zero();
        this._angularVelocity = __1.Vector3.Zero();
        this._constraints = [];
    }
    /**
     * PUBLIC ACCESSORS
     */
    get velocity() { return this._velocity; }
    set velocity(value) { this._velocity.copy(value); }
    get angularVelocity() { return this._angularVelocity; }
    set angularVelocity(value) { this._angularVelocity.copy(value); }
    get constraints() { return this._constraints; }
    set constraints(value) {
        this._constraints = [...value];
        // TODO: Figure out array patching
        // this._changed("constraints");
    }
    copy(from) {
        if (!from)
            return this;
        if (from.enabled !== undefined)
            this.enabled = from.enabled;
        if (from.velocity !== undefined)
            this._velocity.copy(from.velocity);
        if (from.angularVelocity !== undefined)
            this._angularVelocity.copy(from.angularVelocity);
        if (from.mass !== undefined)
            this.mass = from.mass;
        if (from.detectCollisions !== undefined)
            this.detectCollisions = from.detectCollisions;
        if (from.collisionDetectionMode !== undefined)
            this.collisionDetectionMode = from.collisionDetectionMode;
        if (from.useGravity !== undefined)
            this.useGravity = from.useGravity;
        if (from.constraints !== undefined)
            this.constraints = from.constraints;
        return this;
    }
    toJSON() {
        return {
            enabled: this.enabled,
            velocity: this.velocity.toJSON(),
            angularVelocity: this.angularVelocity.toJSON(),
            mass: this.mass,
            detectCollisions: this.detectCollisions,
            collisionDetectionMode: this.collisionDetectionMode,
            useGravity: this.useGravity,
            constraints: this.constraints,
        };
    }
    movePosition(position) {
        this.$owner.context.internal.sendRigidBodyCommand(this.$owner.id, {
            type: 'rigidbody-move-position',
            position,
        });
    }
    moveRotation(rotation) {
        this.$owner.context.internal.sendRigidBodyCommand(this.$owner.id, {
            type: 'rigidbody-move-rotation',
            rotation,
        });
    }
    addForce(force) {
        this.$owner.context.internal.sendRigidBodyCommand(this.$owner.id, {
            type: 'rigidbody-add-force',
            force,
        });
    }
    addForceAtPosition(force, position) {
        this.$owner.context.internal.sendRigidBodyCommand(this.$owner.id, {
            type: 'rigidbody-add-force-at-position',
            force,
            position,
        });
    }
    addTorque(torque) {
        this.$owner.context.internal.sendRigidBodyCommand(this.$owner.id, {
            type: 'rigidbody-add-torque',
            torque,
        });
    }
    addRelativeTorque(relativeTorque) {
        this.$owner.context.internal.sendRigidBodyCommand(this.$owner.id, {
            type: 'rigidbody-add-relative-torque',
            relativeTorque,
        });
    }
}
exports.RigidBody = RigidBody;
//# sourceMappingURL=rigidbody.js.map